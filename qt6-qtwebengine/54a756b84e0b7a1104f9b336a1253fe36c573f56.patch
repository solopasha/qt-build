Submodule src/3rdparty cc3e3122a..b6deba103:
diff --git a/src/3rdparty/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc b/src/3rdparty/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
index 0be0320ba25..00db9d7ff39 100644
--- a/src/3rdparty/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
+++ b/src/3rdparty/chromium/media/cdm/library_cdm/clear_key_cdm/ffmpeg_cdm_audio_decoder.cc
@@ -183,7 +183,12 @@ bool FFmpegCdmAudioDecoder::Initialize(
   if (codec_context_->sample_fmt == AV_SAMPLE_FMT_S16P)
     codec_context_->request_sample_fmt = AV_SAMPLE_FMT_S16;
 
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+  const AVCodec* codec =
+      FindDecoder(codec_context_->codec_id, codec_context_->codec_whitelist);
+#else
   const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+#endif
   if (!codec || avcodec_open2(codec_context_.get(), codec, NULL) < 0) {
     DLOG(ERROR) << "Could not initialize audio decoder: "
                 << codec_context_->codec_id;
diff --git a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
index c4425cb093f..1b75cd22cb5 100644
--- a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
+++ b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.cc
@@ -34,6 +34,11 @@
 #endif
 #endif
 
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+extern "C" {
+#include <libavutil/avstring.h>
+}
+#endif
 namespace media {
 
 namespace {
@@ -72,6 +77,24 @@ static_assert(
     VideoFrame::kFrameAddressAlignment % kFFmpegBufferAddressAlignment == 0,
     "VideoFrame frame address alignment does not fit ffmpeg requirement");
 
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+const AVCodec* FindDecoder(AVCodecID id, const char* whitelist) {
+  if (!whitelist) {
+    return avcodec_find_decoder(id);
+  }
+
+  void* i = 0;
+  const AVCodec* codec;
+  while (codec = av_codec_iterate(&i)) {
+    if (av_codec_is_decoder(codec) && codec->id == id &&
+        av_match_list(codec->name, whitelist, ',')) {
+      return codec;
+    }
+  }
+  return nullptr;
+}
+#endif
+
 static const AVRational kMicrosBase = { 1, base::Time::kMicrosecondsPerSecond };
 
 base::TimeDelta ConvertFromTimeBase(const AVRational& time_base,
diff --git a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h
index e19d72b7aa2..00ce86828ee 100644
--- a/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h
+++ b/src/3rdparty/chromium/media/ffmpeg/ffmpeg_common.h
@@ -93,6 +93,12 @@ inline base::span<const uint8_t> AVPacketData(const AVPacket& packet) {
       base::span(packet.data, base::checked_cast<size_t>(packet.size)));
 }
 
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+// Systemlib friendly version of avcodec_find_decoder that respects the
+// whitelisted codecs.
+MEDIA_EXPORT const AVCodec* FindDecoder(AVCodecID id, const char* whitelist);
+#endif
+
 // Converts an int64_t timestamp in |time_base| units to a base::TimeDelta.
 // For example if |timestamp| equals 11025 and |time_base| equals {1, 44100}
 // then the return value will be a base::TimeDelta for 0.25 seconds since that
diff --git a/src/3rdparty/chromium/media/filters/audio_file_reader.cc b/src/3rdparty/chromium/media/filters/audio_file_reader.cc
index d577cd5eba6..2f38337584a 100644
--- a/src/3rdparty/chromium/media/filters/audio_file_reader.cc
+++ b/src/3rdparty/chromium/media/filters/audio_file_reader.cc
@@ -102,7 +102,12 @@ bool AudioFileReader::OpenDemuxer() {
 }
 
 bool AudioFileReader::OpenDecoder() {
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+  const AVCodec* codec =
+      FindDecoder(codec_context_->codec_id, codec_context_->codec_whitelist);
+#else
   const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+#endif
   if (codec) {
     // MP3 decodes to S16P which we don't support, tell it to use S16 instead.
     if (codec_context_->sample_fmt == AV_SAMPLE_FMT_S16P)
diff --git a/src/3rdparty/chromium/media/filters/ffmpeg_audio_decoder.cc b/src/3rdparty/chromium/media/filters/ffmpeg_audio_decoder.cc
index 1ab980391e7..6957e4ad32c 100644
--- a/src/3rdparty/chromium/media/filters/ffmpeg_audio_decoder.cc
+++ b/src/3rdparty/chromium/media/filters/ffmpeg_audio_decoder.cc
@@ -365,19 +365,8 @@ bool FFmpegAudioDecoder::ConfigureDecoder(const AudioDecoderConfig& config) {
   }
 
 #if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
-  // Workaround http://crbug.com/41492567
-  // Chromium only supports the 'libopus' decoder.
-  // 'avcodec_find_decoder' finds the experimental 'opus' decoder first
-  // because the lookup is based on codec_id and both have the same id.
-  // Bundled ffmpeg only have libopus but the system usually have both.
-  const AVCodec* codec = [&config, this]() {
-    if (config.codec() == AudioCodec::kOpus)
-      return avcodec_find_decoder_by_name("libopus");
-    if (config.codec() == AudioCodec::kMP3) {
-      return avcodec_find_decoder_by_name("mp3");
-    }
-    return avcodec_find_decoder(codec_context_->codec_id);
-  }();
+  AVCodecID id = AudioCodecToCodecID(config.codec(), config.sample_format());
+  const AVCodec* codec = FindDecoder(id, codec_context_->codec_whitelist);
 #else
   const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
 #endif
diff --git a/src/3rdparty/chromium/media/filters/ffmpeg_glue.cc b/src/3rdparty/chromium/media/filters/ffmpeg_glue.cc
index a8e90b8815c..a5b5a587766 100644
--- a/src/3rdparty/chromium/media/filters/ffmpeg_glue.cc
+++ b/src/3rdparty/chromium/media/filters/ffmpeg_glue.cc
@@ -261,20 +261,27 @@ bool FFmpegGlue::OpenContext(bool is_local_file) {
   LogContainer(is_local_file, container_);
 
 #if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
-  // Sometimes FFmpeg is not aware of the whitelisted codecs and
-  // configures streams and demuxers with unsupported codecs/params.
-  // Force the correct codecs to avoid problems later.
+  // 'avformat_find_stream_info' is not aware of the whitelisted codecs.
+  // However it respects the codecs set in the format_context.
+  // Try to force the correct codecs here at context creation.
   // https://ffmpeg.org/doxygen/7.0/structAVFormatContext.html#a52f39351b15890ef57cc6ff0ec9ab42d
   // https://ffmpeg.org/doxygen/7.0/structAVFormatContext.html#ae5e087f4623b907517c0f7dd8327387d
 
-  // Note: don't forget to update FFmpeg[Audio|Video]Decoder::ConfigureDecoder
-
-  if (strcmp(format_context_->iformat->name, "mp3") == 0) {
-    const AVCodec* mp3_codec = avcodec_find_decoder_by_name("mp3");
-    if (mp3_codec) {
-      format_context_->audio_codec = mp3_codec;
-    } else {
-      LOG(ERROR) << "No supported codec for mp3";
+  for (int i = 0; i < format_context_->nb_streams; i++) {
+    AVCodecParameters *params = format_context_->streams[i]->codecpar;
+    if (!params)
+      continue;
+    const AVCodec* audio_codec =
+        FindDecoder(params->codec_id, GetAllowedAudioDecoders());
+    if (audio_codec) {
+      if (format_context_->audio_codec &&
+          format_context_->audio_codec != audio_codec) {
+        LOG(INFO) << "Conflicting codecs " << format_context_->audio_codec->name
+                  << ", " << audio_codec->name;
+        format_context_->audio_codec = nullptr;
+        break;
+      }
+      format_context_->audio_codec = audio_codec;
     }
   }
 #endif
diff --git a/src/3rdparty/chromium/media/filters/ffmpeg_video_decoder.cc b/src/3rdparty/chromium/media/filters/ffmpeg_video_decoder.cc
index 3f9cef0391a..4da78a8e9f2 100644
--- a/src/3rdparty/chromium/media/filters/ffmpeg_video_decoder.cc
+++ b/src/3rdparty/chromium/media/filters/ffmpeg_video_decoder.cc
@@ -504,7 +504,12 @@ bool FFmpegVideoDecoder::ConfigureDecoder(const VideoDecoderConfig& config,
     codec_context_->flags2 |= AV_CODEC_FLAG2_CHUNKS;
   }
 
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+  const AVCodec* codec =
+      FindDecoder(codec_context_->codec_id, codec_context_->codec_whitelist);
+#else
   const AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);
+#endif
   if (!codec || avcodec_open2(codec_context_.get(), codec, NULL) < 0) {
     ReleaseFFmpegResources();
     return false;
diff --git a/src/3rdparty/chromium/media/filters/media_file_checker.cc b/src/3rdparty/chromium/media/filters/media_file_checker.cc
index 2f4d83de5d9..fce4e26a14f 100644
--- a/src/3rdparty/chromium/media/filters/media_file_checker.cc
+++ b/src/3rdparty/chromium/media/filters/media_file_checker.cc
@@ -74,7 +74,12 @@ bool MediaFileChecker::Start(base::TimeDelta check_time) {
       auto context = AVStreamToAVCodecContext(format_context->streams[i]);
       if (!context)
         continue;
+#if BUILDFLAG(IS_QTWEBENGINE) && BUILDFLAG(USE_SYSTEM_FFMPEG)
+      const AVCodec* codec =
+          FindDecoder(cp->codec_id, context->codec_whitelist);
+#else
       const AVCodec* codec = avcodec_find_decoder(cp->codec_id);
+#endif
       if (codec && avcodec_open2(context.get(), codec, nullptr) >= 0) {
         auto loop = std::make_unique<FFmpegDecodingLoop>(context.get());
         stream_contexts[i] = {std::move(context), std::move(loop)};
